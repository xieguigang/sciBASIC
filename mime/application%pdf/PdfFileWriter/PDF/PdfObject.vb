#Region "Microsoft.VisualBasic::a90958af1b318e720722c8c881c32842, mime\application%pdf\PdfFileWriter\PDF\PdfObject.vb"

    ' Author:
    ' 
    '       asuka (amethyst.asuka@gcmodeller.org)
    '       xie (genetics@smrucc.org)
    '       xieguigang (xie.guigang@live.com)
    ' 
    ' Copyright (c) 2018 GPL3 Licensed
    ' 
    ' 
    ' GNU GENERAL PUBLIC LICENSE (GPL3)
    ' 
    ' 
    ' This program is free software: you can redistribute it and/or modify
    ' it under the terms of the GNU General Public License as published by
    ' the Free Software Foundation, either version 3 of the License, or
    ' (at your option) any later version.
    ' 
    ' This program is distributed in the hope that it will be useful,
    ' but WITHOUT ANY WARRANTY; without even the implied warranty of
    ' MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    ' GNU General Public License for more details.
    ' 
    ' You should have received a copy of the GNU General Public License
    ' along with this program. If not, see <http://www.gnu.org/licenses/>.



    ' /********************************************************************************/

    ' Summaries:


    ' Code Statistics:

    '   Total Lines: 397
    '    Code Lines: 155
    ' Comment Lines: 176
    '   Blank Lines: 66
    '     File Size: 15.16 KB


    ' Class PdfObject
    ' 
    '     Properties: Document, ScaleFactor
    ' 
    '     Constructor: (+2 Overloads) Sub New
    ' 
    '     Function: Adler32Checksum, BuildResourcesDictionary, CompareTo, CompressStream, Round
    '               ToPt
    ' 
    '     Sub: ObjectValueAppend, ObjectValueFormat, WriteObjectToPdfFile
    ' 
    ' /********************************************************************************/

#End Region

'
'
'	PdfFileWriter
'	PDF File Write C# Class Library.
'
'	PdfObject
'	Base class for all PDF indirect object classes.
'
'	Uzi Granot
'	Version: 1.0
'	Date: April 1, 2013
'	Copyright (C) 2013-2019 Uzi Granot. All Rights Reserved
'
'	PdfFileWriter C# class library and TestPdfFileWriter test/demo
'  application are free software.
'	They is distributed under the Code Project Open License (CPOL).
'	The document PdfFileWriterReadmeAndLicense.pdf contained within
'	the distribution specify the license agreement and other
'	conditions and notes. You must read this document and agree
'	with the conditions specified in order to use this software.
'
'	For version history please refer to PdfDocument.cs
'
'

Imports System.IO
Imports System.IO.Compression
Imports System.Text
Imports System.Threading
Imports i32 = Microsoft.VisualBasic.Language.i32
Imports stdNum = System.Math

''' <summary>
''' PDF indirect object base class
''' </summary>
''' <remarks>
''' PDF indirect object base class.
''' User program cannot call it directly.
''' </remarks>
Public Class PdfObject : Implements IComparable(Of PdfObject)

    ''' <summary>
    ''' PDF document object
    ''' </summary>
    ''' <returns></returns>
    Public Property Document As PdfDocument
    ''' <summary>
    ''' Scale factor
    ''' </summary>
    ''' <returns></returns>
    ''' <remarks>Convert from user unit of measure to points.</remarks>
    Public Property ScaleFactor As Double

    ''' <summary>
    ''' PDF indirect object number
    ''' </summary>
    Friend ObjectNumber As Integer
    ''' <summary>
    ''' resource code automatically generated by the program
    ''' </summary>
    Friend ResourceCode As String
    ''' <summary>
    ''' PDF file position for this indirect object
    ''' </summary>
    Friend FilePosition As Long
    ''' <summary>
    ''' object type
    ''' </summary>
    Friend ObjectType As ObjectType
    Friend ObjectValueList As List(Of Byte)
    Friend ObjectValueArray As Byte()
    ''' <summary>
    ''' indirect objects dictionary or stream dictionary
    ''' </summary>
    Friend Dictionary As PdfDictionary
    Friend NoCompression As Boolean
    Private Shared ResCodeStr As String() = {"/Font <<", "/Pattern <<", "/Shading <<", "/XObject <<", "/ExtGState <<", "/Properties <<"}
    Friend Shared ResCodeLetter As String = "FPSXGO"

    Friend Sub New()
    End Sub

    ''' <summary>
    ''' Constructor for objects with /Type in their dictionary
    ''' Note: access is internal. Used by derived classes only
    ''' </summary>
    ''' <param name="Document"></param>
    ''' <param name="Type"></param>
    ''' <param name="PdfDictType"></param>
    Friend Sub New(Document As PdfDocument, Optional Type As ObjectType = ObjectType.Dictionary, Optional PdfDictType As String = Nothing)    ' object type (i.e. /Catalog, /Pages, /Font, /XObject, /OCG)
        ' save link to main document object
        Me.Document = Document

        ' save scale factor
        ScaleFactor = Document.ScaleFactor

        ' save type
        ObjectType = Type

        ' no compression
        NoCompression = Document.Debug

        ' if object is stream or a dictionary define empty dictionary
        If Type <> ObjectType.Other Then Dictionary = New PdfDictionary(Me)

        ' if object is not a dictionary define empty contents stream
        If Type <> ObjectType.Dictionary Then ObjectValueList = New List(Of Byte)()

        ' if object name is specified, create a dictionary and add /Type Name entry
        If Not String.IsNullOrEmpty(PdfDictType) Then Dictionary.Add("/Type", PdfDictType)

        ' set PDF indirect object number to next available number
        ObjectNumber = Document.ObjectArray.Count + 1

        ' add the new object to object array
        Document.ObjectArray.Add(Me)
        Return
    End Sub

    ''' <summary>
    ''' Compare the resource codes of two PDF objects.
    ''' </summary>
    ''' <param name="Other">Other PdfObject</param>
    ''' <returns>Compare result</returns>
    ''' <remarks>
    ''' Used by PdfContents to maintain resource objects in sorted order.
    ''' </remarks>
    Public Function CompareTo(Other As PdfObject) As Integer Implements IComparable(Of PdfObject).CompareTo
        ' the second object
        Return String.Compare(ResourceCode, Other.ResourceCode)
    End Function

    ''' <summary>
    ''' Convert user coordinates or line width to points.
    ''' The result is rounded to 6 decimal places and converted to Single.
    ''' </summary>
    ''' <param name="Value">
    ''' coordinate value in user unit of measure
    ''' </param>
    ''' <returns></returns>
    Friend Function ToPt(Value As Double) As Single
        Dim ReturnValue = ScaleFactor * Value

        If stdNum.Abs(ReturnValue) < 0.0001 Then
            Return 0
        Else
            Return ReturnValue
        End If
    End Function

    ''' <summary>
    ''' Round unscaled numbers.
    ''' </summary>
    ''' <param name="Value">a number to be saved in contents</param>
    ''' <returns>The value is rounded to 6 decimal places and converted to Single</returns>
    Friend Function Round(Value As Double) As Single
        If stdNum.Abs(Value) < 0.0001 Then
            Return 0
        Else
            Return Value
        End If
    End Function

    Friend Sub ObjectValueAppend(Str As String)
        ' convert content from string to binary
        For Each Chr As Char In Str
            ObjectValueList.Add(Microsoft.VisualBasic.AscW(Chr))
        Next
    End Sub

    Friend Sub ObjectValueFormat(FormatStr As String, ParamArray List As Object())
        ' format input arguments
        Dim Str = String.Format(PeriodDecSep, FormatStr, List)

        ' convert content from string to binary
        For Each Chr As Char In Str
            ObjectValueList.Add(Microsoft.VisualBasic.AscW(Chr))
        Next
    End Sub

    ''' <summary>
    ''' Convert resource dictionary to one String.
    ''' This method is called at the last step of document creation
    ''' from within PdfDocument.CreateFile(FileName).
    ''' it is relevant to page contents, X objects and tiled pattern
    ''' </summary>
    ''' <param name="ResObjects">list of resource objects for this contents</param>
    ''' <param name="AddProcSet"></param>
    ''' <returns>Return value is resource dictionary string.</returns>
    Friend Function BuildResourcesDictionary(ResObjects As List(Of PdfObject), AddProcSet As Boolean) As String
        ' for page contents we need /ProcSet 
        ' resource object list is empty
        ' if there are no resources an empty dictionary must be returned
        If ResObjects Is Nothing OrElse ResObjects.Count = 0 Then
            Return If(AddProcSet, "<</ProcSet [/PDF/Text]>>", "<<>>")
        End If

        ' resources dictionary content initialization
        Dim Resources As StringBuilder = New StringBuilder("<<")

        ' for page object
        If AddProcSet Then Resources.Append("/ProcSet [/PDF/Text/ImageB/ImageC/ImageI]" & Microsoft.VisualBasic.Constants.vbLf)

        ' add all resources
        Dim ResCodeType = " "c

        For Each Resource In ResObjects
            ' resource code is /Xnnn
            If Resource.ResourceCode(1) <> ResCodeType Then
                ' terminate last type
                If ResCodeType <> " "c Then Resources.Append(">>" & Microsoft.VisualBasic.Constants.vbLf)

                ' start new type
                ResCodeType = Resource.ResourceCode(1)
                Resources.Append(ResCodeStr(ResCodeLetter.IndexOf(ResCodeType)))
            End If

            ' append resource code
            If Resource.GetType() IsNot GetType(PdfFont) Then
                Resources.Append(String.Format("{0} {1} 0 R", Resource.ResourceCode, Resource.ObjectNumber))
            Else
                Dim Font = CType(Resource, PdfFont)
                If Font.FontResCodeUsed Then Resources.Append(String.Format("{0} {1} 0 R", Font.ResourceCode, Font.ObjectNumber))
                If Font.FontResGlyphUsed Then Resources.Append(String.Format("{0} {1} 0 R", Font.ResourceCodeGlyph, Font.GlyphIndexFont.ObjectNumber))
            End If
        Next

        ' terminate last type and resource dictionary
        Resources.Append(">>" & Microsoft.VisualBasic.Constants.vbLf & ">>")

        ' exit
        Return Resources.ToString()
    End Function

    ''' <summary>
    ''' Write object to PDF file
    ''' Called by PdfDocument.CreateFile(FileName) method
    ''' to output one indirect PDF object.
    ''' It is a virtual method. Derived classes can overwrite it.
    ''' </summary>
    Friend Overridable Sub WriteObjectToPdfFile()
        ' save file position for this object
        FilePosition = Document.PdfFile.BaseStream.Position

        ' write object header
        Document.PdfFile.WriteFormat("{0} 0 obj" & Microsoft.VisualBasic.Constants.vbLf, ObjectNumber)

        ' switch based on the type of PDF indirect object
        Select Case ObjectType
            Case ObjectType.Stream
                ' convert byte list to array
                If ObjectValueList.Count > 0 Then ObjectValueArray = ObjectValueList.ToArray()

                ' application test
                If ObjectValueArray Is Nothing Then ObjectValueArray = New Byte(-1) {}

                ' compression is disabled
                If Not NoCompression Then ObjectValueArray = CompressStream(ObjectValueArray)

                ' encryption
                If Document.Encryption IsNot Nothing Then ObjectValueArray = Document.Encryption.EncryptByteArray(ObjectNumber, ObjectValueArray)

                ' stream length
                Dictionary.AddInteger("/Length", ObjectValueArray.Length)

                ' write dictionary
                Dictionary.WriteToPdfFile()

                ' write stream reserved word
                Document.PdfFile.WriteString("stream" & Microsoft.VisualBasic.Constants.vbLf)

                ' write content to pdf file
                Document.PdfFile.Write(ObjectValueArray)

                ' write end of stream
                Document.PdfFile.WriteString(Microsoft.VisualBasic.Constants.vbLf & "endstream" & Microsoft.VisualBasic.Constants.vbLf & "endobj" & Microsoft.VisualBasic.Constants.vbLf)
            Case ObjectType.Dictionary
                ' write dictionary
                Dictionary.WriteToPdfFile()

                ' output object trailer
                Document.PdfFile.WriteString("endobj" & Microsoft.VisualBasic.Constants.vbLf)
            Case ObjectType.Other
                ' convert byte list to array
                If ObjectValueList.Count > 0 Then ObjectValueArray = ObjectValueList.ToArray()

                ' we have contents but no dictionary
                ' write content to pdf file
                Document.PdfFile.Write(ObjectValueArray)

                ' output object trailer
                Document.PdfFile.WriteString(Microsoft.VisualBasic.Constants.vbLf & "endobj" & Microsoft.VisualBasic.Constants.vbLf)
        End Select

        ' resources not used
        Dictionary = Nothing
        ObjectValueList = Nothing
        ObjectValueArray = Nothing
    End Sub

    ''' <summary>
    ''' Compress byte array
    ''' </summary>
    ''' <param name="InputBuf"></param>
    ''' <returns></returns>
    Friend Function CompressStream(InputBuf As Byte()) As Byte()
        ' input length
        Dim InputLen = InputBuf.Length

        ' input buffer too small to compress
        If InputLen < 16 Then Return InputBuf

        ' create output memory stream to receive the compressed buffer
        Dim OutputStream As MemoryStream = New MemoryStream()

        ' deflate compression object
        Dim Deflate As DeflateStream = New DeflateStream(OutputStream, CompressionMode.Compress, True)

        ' load input buffer into the compression class
        Deflate.Write(InputBuf, 0, InputBuf.Length)

        ' compress, flush and close
        Deflate.Close()

        ' compressed file length
        Dim OutputLen As Integer = OutputStream.Length

        ' make sure compressed stream is shorter than input stream
        If OutputLen + 6 >= InputLen Then Return InputBuf

        ' create output buffer
        Dim OutputBuf = New Byte(OutputLen + 6 - 1) {}

        ' write two bytes in most significant byte first
        OutputBuf(0) = &H78
        OutputBuf(1) = &H9C

        ' copy the compressed result
        OutputStream.Seek(0, SeekOrigin.Begin)
        OutputStream.Read(OutputBuf, 2, OutputLen)
        OutputStream.Close()

        ' reset adler32 checksum
        Dim ReadAdler32 = Adler32Checksum(InputBuf)

        ' ZLib checksum is Adler32 write it big endian order, high byte first
        OutputLen += 2
        OutputBuf(stdNum.Min(Interlocked.Increment(OutputLen), OutputLen - 1)) = CByte(ReadAdler32 >> 24)
        OutputBuf(stdNum.Min(Interlocked.Increment(OutputLen), OutputLen - 1)) = CByte(ReadAdler32 >> 16)
        OutputBuf(stdNum.Min(Interlocked.Increment(OutputLen), OutputLen - 1)) = CByte(ReadAdler32 >> 8)
        OutputBuf(OutputLen) = CByte(ReadAdler32)

        ' update dictionary
        Dictionary.Add("/Filter", "/FlateDecode")

        ' successful exit
        Return OutputBuf
    End Function

    ''' <summary>
    ''' Accumulate Adler Checksum
    ''' </summary>
    ''' <param name="Buffer"></param>
    ''' <returns></returns>
    Private Function Adler32Checksum(Buffer As Byte()) As UInteger
        Const Adler32Base As UInteger = 65521

        ' split current Adler checksum into two 
        Dim AdlerLow As UInteger = 1 ' AdlerValue & 0xFFFF;
        Dim AdlerHigh As UInteger = 0 ' AdlerValue >> 16;
        Dim Len = Buffer.Length
        Dim Pos As i32 = 0

        While Len > 0
            ' We can defer the modulo operation:
            ' Under worst case the starting value of the two halves is 65520 = (AdlerBase - 1)
            ' each new byte is maximum 255
            ' The low half grows AdlerLow(n) = AdlerBase - 1 + n * 255
            ' The high half grows AdlerHigh(n) = (n + 1)*(AdlerBase - 1) + n * (n + 1) * 255 / 2
            ' The maximum n before overflow of 32 bit unsigned integer is 5552
            ' it is the solution of the following quadratic equation
            ' 255 * n * n + (2 * (AdlerBase - 1) + 255) * n + 2 * (AdlerBase - 1 - uint.MaxValue) = 0
            Dim n = If(Len < 5552, Len, 5552)
            Len -= n

            While Interlocked.Decrement(n) >= 0
                AdlerLow += Buffer(++Pos)
                AdlerHigh += AdlerLow
            End While

            AdlerLow = AdlerLow Mod Adler32Base
            AdlerHigh = AdlerHigh Mod Adler32Base
        End While

        Return AdlerHigh << 16 Or AdlerLow
    End Function
End Class
